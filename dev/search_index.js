var documenterSearchIndex = {"docs":
[{"location":"credits/#Credits","page":"Credits","title":"Credits","text":"","category":"section"},{"location":"credits/","page":"Credits","title":"Credits","text":"Contributors to this package include Anshrin Srivastava, Mykel Kochenderfer, Dylan Asmar, and Tim Wheeler.","category":"page"},{"location":"usage/#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"To use the DividedRectangles module, start your code with:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using DividedRectangles","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"The optimize function is the primary function of the DividedRectangles module. It implements the DIRECT algorithm to find the minimum of a given objective function within specified bounds.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"To use the optimize function with a custom objective function::","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using DividedRectangles\n\n# Define the objective function\nf(x) = x[1]^2 + x[2]^2 + 3 * sin(5 * x[1]) + 2 * cos(3 * x[2])  # Multivariate example\n\n# Set the search bounds\na = [-2.0, -2.0]\nb = [2.0, 2.0]\n\n# Call the optimization function\nresult = optimize(f, a, b)\n\nprintln(\"Best design found: \", result)\n","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Arguments:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"f: The objective function to be minimized.\na: Vector of lower bounds for the search space.\nb: Vector of upper bounds for the search space.\nmax_iterations: (Optional) The maximum number of iterations (default: 100).\nmin_radius: (Optional) The minimum radius of hyper-rectangles (default: 1e-5).","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Returns: ","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"The best design x found by DIRECT.","category":"page"},{"location":"algorithm/#Algorithm","page":"Algorithm","title":"Algorithm","text":"","category":"section"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"The divided rectangles algorithm, or DIRECT (for DIvided RECTangles), incrementally refines a retangular partition of the design space. The refinement is driven by a heuristic that involves reasoning about potential Lipschitz constants. ","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"The strength of the DIRECT algorithm lies in its ability to systematically explore the entire search space while focusing on the most promising areas. This systematic coverage helps the algorithm escape local minima, making it particularly effective for objective functions with multiple local minima. ","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"Additionally, by not requiring the Lipschitz constant, the DIRECT algorithm is adaptable to various optimization problems, including those where the smoothness of the objective function is not well understood.","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"The figure below shows the DIRECT method after 16 iterations on the Branin function. The cells are much denser around the minima of the Branin function because the DIRECT method is designed to increase its resolution in promising regions.","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"(Image: page_11)","category":"page"},{"location":"algorithm/#Key-Concepts-of-the-DIRECT-Algorithm","page":"Algorithm","title":"Key Concepts of the DIRECT Algorithm","text":"","category":"section"},{"location":"algorithm/#**Search-Space**:","page":"Algorithm","title":"Search Space:","text":"","category":"section"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"The algorithm minimizes an objective function f(x) over a hyper-rectangular search space. The search space is then normalized to the unit hypercube to avoid oversensitivity to dimensions with larger domains. If given an objective function f(x) in the interval between lower and upper domains a and b, DIRECT will instead minimize:","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"   g(mathbfx) = f(mathbfx odot (mathbfb - mathbfa) + mathbfa)","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"After finding the minimum x^* of g, the minimizer of f is:","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"mathbfx^* odot (mathbfb - mathbfa) + mathbfa","category":"page"},{"location":"algorithm/#**Function-Evaluation**:","page":"Algorithm","title":"Function Evaluation:","text":"","category":"section"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"DIRECT partitions its search space into hyperrectangular intervals. The objective function is evaluated at the center of each hyperrectangle. Each interval has a center c^(i), an associated objective function value f(c^(i)), and a radius r^(i). The radius is the distance from the center to a vertex.","category":"page"},{"location":"algorithm/#**Selection-of-Potentially-Optimal-Rectangles**:","page":"Algorithm","title":"Selection of Potentially Optimal Rectangles:","text":"","category":"section"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"In each iteration, the algorithm identifies potentially optimal intervals. An interval is considered potentially optimal if there exists a Lipschitz constant such that said interval could contain the global minimum based on the evaluations performed so far.","category":"page"},{"location":"algorithm/#Lipschitz-Lower-Bound:","page":"Algorithm","title":"Lipschitz Lower Bound:","text":"","category":"section"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"The Lipschitz lower bound for an interval is a circular cone extending downward from its center c^(i):","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"  f(mathbfx) geq f(mathbfc^(i)) - ell mathbfx - mathbfc^(i)_2","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"This lower bound is constrained by the extents of the interval, and its lowest value is achieved at the vertices, which are all a distance r^(i) from the center.","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"f(c^(i)) - ell r^(i)","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"The left plot below shows the intervals for the DIRECT method after 5 iterations on the Branin function. The right plot shows the interval objective function values versus their radii, which is useful for identifying intervals to split with further evaluations.","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"(Image: page_12)","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"The left plot below shows the Lipschitz lowerbounds constructed for the DIRECT intervals using the Lipschitz constant = 200, and highlights one interval. The right plot shows how the minimum value for the lowerbound within the highlighted interval is the same as the x-intercept for a line of slope passing through that intervalâ€™s (r f(c)) point.","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"(Image: page_13)","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"The left plot below continues to show the Lipschitz lowerbounds constructed for the DIRECT intervals using the Lipschitz constant = 200, but now highlights the interval containing the lowest value. The right plot shows how the lowest lowerbound for a given Lipschitz constant is the one with the lowest x-intercept in the right-hand plot.","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"(Image: page_14)","category":"page"},{"location":"algorithm/#**Recursive-Division**:","page":"Algorithm","title":"Recursive Division:","text":"","category":"section"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"The selected intervals are further divided, splitting into thirds along the axis directions. The order in which dimensions are split matters; lower function evaluations receive larger sub-rectangles. The process continues recursively, refining the search by focusing on the most promising regions.","category":"page"},{"location":"algorithm/#**Convex-Hull**:","page":"Algorithm","title":"Convex Hull:","text":"","category":"section"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"The DIRECT method selects all intervals for which a Lipschitz constant exists such that their lower bounds have minimal value. These intervals form a piecewise-linear boundary along the lower-right of the (r f(c)) space.","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"The left plot shows the split intervals identified for this iteration of DIRECT on the Branin function. The right plot shows the lower-right convex hull formed by these split intervals in (r f(c)) space.","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"(Image: page_15)","category":"page"},{"location":"algorithm/#Splitting-Intervals","page":"Algorithm","title":"Splitting Intervals","text":"","category":"section"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"When splitting a region without equal side lengths, only the longest dimensions are split. Splitting proceeds on these dimensions in the same manner as with a hypercube. The width in a given dimension depends on how many times that dimension has been split. Since DIRECT always splits axis directions by thirds, a dimension that has been split d times will have a width of 3^d. If we have n dimensions and track how many times each dimension of a given interval has been split in a vector d, then the radius of that interval is","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"r = leftleft frac12 cdot 3^-d_1 dots frac12 cdot 3^-d_n rightright_2","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"The figure below shows how interval splitting in for DIRECT requires choosing an ordering for the split dimensions:","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"(Image: page_16)","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"DIRECT will only split the longest dimensions of intervals:","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"(Image: page_17)","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"Finally, DIRECT only splits intervals larger than a minimum radius. This minimum radius prevents inefficient function evaluations very close to existing points.","category":"page"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"To install the package, start Julia and run the following command:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(url=\"https://github.com/sisl/DividedRectangles.jl\")\n","category":"page"},{"location":"#DividedRectangles.jl","page":"Home","title":"DividedRectangles.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: CI) (Image: Documentation Status) (Image: codecov)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Important Note: The content in this package is borrowed from Chapter 7, \"Direct Methods,\" of the forthcoming second edition of \"Algorithms for Optimization\" by Mykel Kochenderfer and Tim Wheeler.","category":"page"},{"location":"","page":"Home","title":"Home","text":"DividedRectangles.jl provides an implementation of the DIRECT (DIvided RECTangles) algorithm for global optimization. The DIRECT algorithm is particularly useful for optimizing functions where the Lipschitz constant is unknown. This package allows users to perform both univariate and multivariate optimization efficiently.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The figure below shows the DIRECT method after 16 iterations on the Branin function. The cells are much denser around the minima of the Branin function because the DIRECT method is designed to increase its resolution in promising regions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: page_11)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This documentation provides detailed usage examples, theoretical background, and advanced customization options to help you get the most out of DividedRectangles.jl.","category":"page"}]
}
