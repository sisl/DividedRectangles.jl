var documenterSearchIndex = {"docs":
[{"location":"credits/#Credits","page":"Credits","title":"Credits","text":"","category":"section"},{"location":"credits/","page":"Credits","title":"Credits","text":"Contributors to this package include Anshrin Srivastava, Mykel Kochenderfer, Dylan Asmar, and Tim Wheeler.","category":"page"},{"location":"theory/#Algorithm","page":"Theory","title":"Algorithm","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"The divided rectangles algorithm, or DIRECT (for DIvided RECTangles), incrementally refines a retangular partition of the design space. The refinement is driven a heuristic that involves reasoning about potential Lipschitz constants.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"","category":"page"},{"location":"theory/#Key-Concepts-of-the-DIRECT-Algorithm","page":"Theory","title":"Key Concepts of the DIRECT Algorithm","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Division of Search Space:\nThe algorithm begins by treating the entire feasible region as a single hyper-rectangle.\nThe search space is normalized to the unit hypercube to avoid oversensitivity to dimensions with larger domains. If minimizing f(x) in the interval between lower and upper ranges a and b, DIRECT will instead minimize:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"   g(mathbfx) = f(mathbfx odot (mathbfb - mathbfa) + mathbfa)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"After finding the minimum x^* of g, the minimum of f is","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"mathbfx^* odot (mathbfb - mathbfa) + mathbfa","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The figure below shows DIRECT method after 16 iterations on the Branin function (see the test functions section in the appendix). The cells are much denser around the minima of the Branin function because the DIRECT method is designed to increase resolution in promising regions.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"(Image: page_11)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Function Evaluation:\nThe function is evaluated at the center of each hyper-rectangle.\nEach interval has a center c^(i)  and an associated objective function value f(c^(i)), as well as a radius r^(i), which is the distance from the center to a vertex.\nSelection of Potentially Optimal Rectangles:\nAfter evaluation, the algorithm identifies potentially optimal rectangles. A rectangle is considered potentially optimal if it could contain the global minimum based on the evaluations performed so far.\nLipschitz Lower Bound:\nThe Lipschitz lower bound for an interval is a circular cone extending downward from its center c^(i)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"f(mathbfx) geq f(mathbfc^(i)) - ell mathbfx - mathbfc^(i)_2","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"This lower bound is constrained by the extents of the interval, and its lowest value is achieved at the vertices, which are all a distance r^(i) from the center.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"f(c^(i)) - ell r^(i)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The left plot shows the intervals for the DIRECT method after 5 iterations on the Branin function, see the test functions section in the appendix. The right plot shows the interval objective function values versus their radii, which is useful for identifying intervals to split with further evaluations.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"(Image: page_12)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The left plot shows the Lipschitz lowerbounds constructed for the DIRECT intervals using the Lipschitz constant = 200, and highlights one interval. The right plot shows how the minimum value for the lowerbound within the highlighted interval is the same as the x-intercept for a line of slope passing through that interval‚Äôs (r f(c)) point.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"(Image: page_13)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The left plot continues to show the Lipschitz lowerbounds constructed for the DIRECT intervals using the Lipschitz constant = 200, but now highlights the interval containing the lowest value. The right plot shows how the lowest lowerbound for a given Lipschitz constant is the one with the lowest x-intercept in the right-hand plot.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"(Image: page_14)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Recursive Division:\nThe selected rectangles are further divided, splitting into thirds along the axis directions. The order in which dimensions are split matters; lower function evaluations receive larger sub-rectangles. The process continues recursively, refining the search by focusing on the most promising regions.\nConvex Hull:\nThe DIRECT method selects all intervals for which a Lipschitz constant exists such that their lower bounds have minimal value. These intervals form a piecewise-linear boundary along the lower-right of the (r f(c)) space.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The left plot shows the split intervals identified for this iteration of DIRECT on the Branin function. The right plot shows the lower-right convex hull formed by these split intervals in (r f(c)) space.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"(Image: page_15)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"","category":"page"},{"location":"theory/#Splitting-Intervals","page":"Theory","title":"Splitting Intervals","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"When splitting a region without equal side lengths, only the longest dimensions are split (figure 7.17). Splitting proceeds on these dimensions in the same manner as with a hypercube. The width in a given dimension depends on how many times that dimension has been split. Since DIRECT always splits axis directions by thirds, a dimension that has been split d times will have a width of 3^d. If we have n dimensions and track how many times each dimension of a given interval has been split in a vector d, then the radius of that interval is","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"r = sqrtleft( frac12 cdot 3^-d_1 right)^2  ldots  left( frac12 cdot 3^-d_n right)^2","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Interval splitting in multiple dimensions for DIRECT requires choosing an ordering for the split dimensions","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"(Image: page_16)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"DIRECT will only split the longest dimensions of intervals.  The algorithm only divides intervals larger than a minimum radius. This minimum radius prevents inefficient function evaluations very close to existing points.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"(Image: page_17)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"","category":"page"},{"location":"theory/#Practical-Implementations:","page":"Theory","title":"Practical Implementations:","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Struct DirectRectangle:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"   struct DirectRectangle\n    c  # center point\n    y  # center point value\n    d  # number of divisions per dimension\n    r  # the radius of the interval\nend","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"direct Function:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"function direct(f, a, b, k_max, r_min)\n    g = x -> f(x .* (b - a) + a)  # evaluate within unit hypercube\n    n = length(a)\n    c = fill(0.5, n)\n    ‚ñ°s = [DirectRectangle(c, g(c), fill(0, n), sqrt(0.5^n))]\n    c_best = c\n    for k in 1 : k_max\n        ‚ñ°s_split = get_split_intervals(‚ñ°s, r_min)\n        setdiff!(‚ñ°s, ‚ñ°s_split)\n        for ‚ñ°_split in ‚ñ°s_split\n            append!(‚ñ°s, split_interval(‚ñ°_split, g))\n        end\n        c_best = ‚ñ°s[findmin(‚ñ°.y for ‚ñ° in ‚ñ°s)[2]].c\n    end\n    return c_best .* (b - a) + a  # from unit hypercube\nend","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"is_ccw Function:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"function is_ccw(a, b, c)\n    return a.r * (b.y - c.y) - a.y * (b.r - c.r) + (b.r * c.y - b.y * c.r) < 1e-6\nend","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"4.get_split_intervalsFunction","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"function get_split_intervals(‚ñ°s, r_min)\n    hull = DirectRectangle[]\n    sort!(‚ñ°s, by = ‚ñ° -> (‚ñ°.r, ‚ñ°.y))\n    for ‚ñ° in ‚ñ°s\n        if length(hull) >= 1 && ‚ñ°.r == hull[end].r\n            continue  # Repeated r values cannot be improvements\n        end\n        if length(hull) >= 1 && ‚ñ°.y ‚â§ hull[end].y\n            pop!(hull)  # Remove the last point if the new one is better\n        end\n        if length(hull) >= 2 && is_ccw(hull[end-1], hull[end], ‚ñ°)\n            pop!(hull)\n        end\n        push!(hull, ‚ñ°)\n    end\n    filter!(‚ñ° -> ‚ñ°.r ‚â• r_min, hull)  # Only split intervals larger than the minimum radius\n    return hull\nend","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"split_interval Function:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"function split_interval(‚ñ°, g)\n    c, n, d_min, d = ‚ñ°.c, length(‚ñ°.c), minimum(‚ñ°.d), copy(‚ñ°.d)\n    dirs, Œ¥ = findall(d .== d_min), 3.0^(-d_min-1)\n    Cs = [(c + Œ¥*basis(i, n), c - Œ¥*basis(i, n)) for i in dirs]\n    Ys = [(g(C[1]), g(C[2])) for C in Cs]\n    minvals = [min(Y[1], Y[2]) for Y in Ys]\n    ‚ñ°s = DirectRectangle[]\n    for j in sortperm(minvals)\n        d[dirs[j]] += 1  # Increment the number of splits\n        C, Y, r = Cs[j], Ys[j], norm(0.5 * 3.0.^(-d))\n        push!(‚ñ°s, DirectRectangle(C[1], Y[1], copy(d), r))\n        push!(‚ñ°s, DirectRectangle(C[2], Y[2], copy(d), r))\n    end\n    r = norm(0.5 * 3.0.^(-d))\n    push!(‚ñ°s, DirectRectangle(c, ‚ñ°.y, d, r))\n    return ‚ñ°s\nend","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"","category":"page"},{"location":"theory/#Strengths-of-the-DIRECT-Algorithm","page":"Theory","title":"Strengths of the DIRECT Algorithm","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"The strength of the DIRECT algorithm lies in its ability to systematically explore the entire search space while focusing on the most promising areas. This systematic coverage helps the algorithm escape local minima, making it particularly effective for objective functions with multiple local minima. By not requiring the Lipschitz constant, the DIRECT algorithm is adaptable to various optimization problems, including those where the smoothness of the objective function is not well understood.","category":"page"},{"location":"usage/#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"To use the DividedRectangles module, start your code with:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using DividedRectangles","category":"page"},{"location":"usage/#Core-Functions","page":"Usage","title":"Core Functions","text":"","category":"section"},{"location":"usage/#optimize","page":"Usage","title":"optimize","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"The optimize function is the primary function of the DividedRectangles module. It implements the DIRECT algorithm to find the minimum of a given objective function within specified bounds.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"To use the optimize function with a custom mathematical function:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using DividedRectangles\n\n# Define the objective function\nf(x) = dot(coeffs, x)\n\n# Call the optimization function\nresult = optimize(f, a, b)\n\nprintln(\"Optimal value found at: \", result)\n","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Arguments:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"f: The objective function to be minimized.\na: Vector of lower bounds for the search space.\nb: Vector of upper bounds for the search space.\nmax_iterations: (Optional) The maximum number of iterations (default: 100).\nmin_radius: (Optional) The minimum radius of hyper-rectangles (default: 1e-5).","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Returns: ","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"The best design ùë• found by DIRECT.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"","category":"page"},{"location":"usage/#Example:-Multivariate-Optimization","page":"Usage","title":"Example: Multivariate Optimization","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"The following example shows how to optimize a multivariate function using the DIRECT algorithm:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using DividedRectangles\n\n# Define the objective function\nf(x) = x[1]^2 + x[2]^2 + 3 * sin(5 * x[1]) + 2 * cos(3 * x[2])\n\n# Set the search bounds\na = [-2.0, -2.0]\nb = [2.0, 2.0]\n\n# Optimize\nresult = DividedRectangles.optimize(f, a, b)\n\nprintln(\"Optimal value found at: \", result)","category":"page"},{"location":"usage/#Parameters","page":"Usage","title":"Parameters","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"f: This is the objective function to minimize. Should be an operation that accepts a vector of Float64 values.\na: A vector with the lower bounds to be used in the search space.\nb: An upper-bound vector for the search space.\nmax_iterations:  Maximum number of iterations to run the optimization. The default is 100.\nmin_radius: The minimum allowable size of a hyper-rectangle (default: '1e-5').","category":"page"},{"location":"usage/#Advanced-Usage","page":"Usage","title":"Advanced Usage","text":"","category":"section"},{"location":"usage/#Fine-Tuning-Optimization:","page":"Usage","title":"Fine-Tuning Optimization:","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"The optimize function offers several parameters for fine-tuning the optimization process:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"max_iterations: Sets the maximum number of iterations to perform. Increasing this value may improve the accuracy of the result but will require more computational time.\nmin_radius: Specifies the minimum allowable size of the hyper-rectangles. This can be adjusted to control the granularity of the search.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Example with custom parameters:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"result = DividedRectangles.optimize(f, a, b, max_iterations=500, min_radius=1e-6)","category":"page"},{"location":"algorithm/#Algorithms","page":"Algorithm","title":"Algorithms","text":"","category":"section"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"Important Note: The content below is borrowed from Chapter 7, \"Direct Methods,\" of the forthcoming second edition of \"Algorithms for Optimization\" by Mykel Kochenderfer and Tim Wheeler.","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"The DIRECT algorithm incrementally refines a rectangular partition of the design space, using a heuristic inspired by potential Lipschitz constants to guide the refinement. This partitioning allows for global optimization by balancing exploration and exploitation of the design space. ","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"","category":"page"},{"location":"algorithm/#Normalization:","page":"Algorithm","title":"Normalization:","text":"","category":"section"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"To simplify the mathematics and avoid oversensitivity to dimensions with larger domains, DIRECT first normalizes the search space to be the unit hypercube.","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"If we are minimizing f(x) in the interval between lower and upper ranges a and b DIRECT will instead minimize:","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"g(mathbfx) = f(mathbfx odot (mathbfb - mathbfa) + mathbfa)","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"After finding the minimum f(x) of g, the minimum of f is:","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"mathbfx^* odot (mathbfb - mathbfa) + mathbfa","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"","category":"page"},{"location":"algorithm/#Partitioning-the-Search-Space:","page":"Algorithm","title":"Partitioning the Search Space:","text":"","category":"section"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"DIRECT maintains a partition of this unit hypercube into hyperrectangular intervals. Each interval has:","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"A center c^(i)\nAn associated objective function value f(c^(i))\nA radius r^(i), which is the distance from the center to a vertex.","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"DIRECT begins every iteration by identifying intervals to be split with additional function evaluations. It splits the intervals for which a Lipschitz constant ell exists such that that interval contains the Lipschitz lowerbound.","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"","category":"page"},{"location":"algorithm/#Splitting-Intervals","page":"Algorithm","title":"Splitting Intervals","text":"","category":"section"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"DIRECT splits the identified intervals along their longest dimensions, dividing each interval into thirds. These splits refine the resolution in areas of interest, increasing accuracy near the minimum while avoiding excessive evaluations in less promising regions. The heuristic ensures that intervals are split in a way that balances the need for exploring the global space and refining local areas of interest.","category":"page"},{"location":"algorithm/#Lipschitz-Lower-Bound","page":"Algorithm","title":"Lipschitz Lower Bound","text":"","category":"section"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"The Lipschitz lower bound for an interval is a circular cone extending downwards from its center c^(i):","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"f(mathbfx) geq f(mathbfc^(i)) - ell mathbfx - mathbfc^(i)_2","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"This lower bound helps guide the decision of which intervals to split. The intervals for which a Lipschitz constant ell exists such that the interval contains the Lipschitz lower bound are selected for further subdivision.","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"","category":"page"},{"location":"algorithm/#Potentially-Optimal-Intervals:","page":"Algorithm","title":"Potentially Optimal Intervals:","text":"","category":"section"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"DIRECT does not rely on a fixed Lipschitz constant. Instead, it selects potentially optimal intervals‚Äîthose where a Lipschitz constant ( \\ell ) could exist that makes the interval contain the global minimum. The process of identifying these intervals forms a lower-right convex hull in ( (r, f(c)) )-space, which guides the algorithm to split the most promising intervals.","category":"page"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"To install the package, start Julia and run the following command:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(url=\"https://github.com/sisl/DividedRectangles.jl\")\n","category":"page"},{"location":"#DividedRectangles.jl","page":"Home","title":"DividedRectangles.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: CI) (Image: Documentation Status) (Image: codecov) ‚Äì-","category":"page"},{"location":"","page":"Home","title":"Home","text":"DividedRectangles.jl provides an implementation of the DIRECT (DIvided RECTangles) algorithm for global optimization. The DIRECT algorithm is particularly useful for optimizing functions where the Lipschitz constant is unknown. This package allows users to perform both univariate and multivariate optimization efficiently.","category":"page"},{"location":"#Key-Equation:","page":"Home","title":"Key Equation:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The algorithm is guided by the following fundamental equation:","category":"page"},{"location":"","page":"Home","title":"Home","text":"f(x) = sum_i=1^n c_i x_i","category":"page"},{"location":"","page":"Home","title":"Home","text":"where:","category":"page"},{"location":"","page":"Home","title":"Home","text":"x_i\nrepresents the variables.\nc_i\nrepresents the coefficients corresponding to each variable.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This equation forms the basis for dividing the search space into smaller rectangles, optimizing the function by evaluating it at specific points.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"This documentation provides detailed usage examples, theoretical background, and advanced customization options to help you get the most out of DividedRectangles.jl.","category":"page"}]
}
